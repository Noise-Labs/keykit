<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<HTML>
<HEAD>
<TITLE>GeoMaestro v1.0</TITLE>
<META NAME="Author" CONTENT="Stéphane Rollandin">
<META NAME="Description" CONTENT="GeoMaestro for KeyKit, v1.0 manual">
<META NAME="Keywords" CONTENT="KeyKit, MIDI, GeoMaestro">
</HEAD>
<BODY>

<H1>GeoMaestro</H1>

<H2>Data Structures</H2>

<BR><BR>
Data structures in GeoMaestro are very simple: they're all plain arrays. I started defining classes then it appeared that KeyKit does not yet efficiently dispose of them (there's no garbage collection for objects). On the other side, Tim made a great job in making array management very simple and powerful. <BR><BR>
So here you will find the required fields and organisation for an array to be correctly managed as a point, a circle, a segment, a scene, a piste or a ligne. Along with these definitions you will have a list of the useful <A HREF="GMfunctions.html">functions</A> more or less related to such arrays. <BR><BR><BR>

We can divide the data structures in two different groups: the internal representations specific to GeoMaestro, such as <B><A HREF="#lignes">lignes</A></B>, <B><A HREF="#pistes">pistes</A></B>, <B><A HREF="#collec">collections</A></B>, <B><A HREF="#events">scenes</A></B>, <B><A HREF="#regions">regions</A></B>,  and the structures for general interest in KeyKit, such as <B><A HREF="#points">points</A></B>, <B><A HREF="#circles">circles</A></B>, <B><A HREF="#segments">segments</A></B>, <B><A HREF="#log">log</A></B> and <B><A HREF="#mem">memories</A></B>.<BR><BR>
<BR><BR>
<HR><HR><BR>
<H2>GeoMaetro internal representations</H2>
<BR>
<HR><BR>
<A NAME="events">First comes the <B>event scene</B>. That's where everything else come from, since it holds the very atoms of compositions: the events.<BR><BR></A>
An event is an array with 4 to 7 fields:<BR><BR>
<B>ev["x"]</B> is the x-position of the event in the scene<BR>
<B>ev["y"]</B> is.. guess what<BR>
<B>ev["nodur"] </B>is the "no"te and "dur"ation of the event. Actually, any valid KeyKit phrase. It should not have a channel value, except if it is to belong to a GeoMaestro channel (ch>16). More of this below.<BR>
<B>ev["actif"] </B>says whether we ignore or not this event. 1 makes it alive, 0 invisible and silent.<BR>
when using the graphic tool, <B>ev["s"]</B> is 1 if the event is part of the current selection.<BR><BR>
Sometimes it can be useful to get rid of the " thing (like in an eval() statement, for exemple). So you can use Xs for "x", Ys for "y", Ph for "nodur", As for "actif" and Ss for "s" (these global variables are defined in <I>initialisations.k</I>)<BR><BR>
So these two event definitions are equivalent:<BR><BR>
ev = ["x"=1, "y"=2, "nodur"='a,bc', "actif"=1] <BR>
ev = [Xs=1, Ys=2, Ph= 'a,bc', As=1]<BR>
<BR><BR>
The 2 other (optional) fields are: <BR><BR>
<B>"label" </B>which is a string containing a name or id for the event, in case you want to give it a special meaning and need a hook to get it (note that you cannot rely on its index in the Ev array since it is submitted to changes)<BR><BR>
<B>"script"</B> may contain the name of a function. This function will be called with automatically computed arguments whenever the event is listened to by a projector. See <A HREF="GMadvanced.html#scripts">here</A> for more about this very powerful feature.<BR><BR>
<BR><BR>
The event scene is storing all events, each event being associated to one of the <B>NbCan</B> channels availables. By default, NbCan is set to 20 (this happens in the <I>initialisations.k</I> file). This is intended to provide 16 MIDI channel, each of them associated to a single instrument/patch, and 4 GeoMaestro channels were you can store complex events with many notes for differents instruments among the 16 previous ones. At least, that's the way I use them, but you don't have to do the same !  But check carefully what happens to channel values, then...<BR><BR>
The event scene is the one and only dedicated global variable <B>Ev</B>. Here is its organisation:<BR><BR>
(ch ranges from 1 to NbCan)<BR><BR>
<B> Ev[ch][0]</B>	number of events in channel ch<BR>
<B> Ev[ch]["PAC"]</B>	initialisation phrase for channel ch<BR>
<B> Ev[ch][n]</B>	event number n in channel ch<BR>
<BR>
As I said before, the nodurs of the events in the first 16 channels should not contain a channel value. Instead, an initialisation phrase (usually a program change message with maybe a bank change) should be stored in the "PAC" field associated to that channel. This phrase will be automatically put at the beginning of any rendered phrase generated by a <A HREF="GMprojectors.html">projector</A>, before any note. More generally, you can put in the "PAC" any phrase you want to see at the beginning of your MIDI file when the corresponding channel is used.<BR><BR>
Now for the GeoMaestro channels: when rendering, the notes from the nodurs will be accordingly attributed to the channel corresponding to their channel value. For example, if Ev[17][1]["nodur"] = 'ac2, bc15' then 'a' will be played on MIDI channel 2 and 'b' on MIDI channel 15, while if Ev[15][1]["nodur"] = 'a, b' then 'a,b' will be played on MIDI channel 15.  <BR><BR>
What's the point here? Well, the main idea is that each GeoMaestro channel have its own set of <A HREF="GMprojectors.html#C3">distortion functions</A>, so that when you attribute an event to a specific channel, you not only associate it with an instrument, but also with a particular way it will be <A HREF="GMprojectors.html#C2">listened to</A>. That makes a big part of the principles of composition in GeoMaestro.
<BR><BR>
I know a lot of what I say here is not so clear, so you're welcome to have a look at the tutorial section when you'll see the whole thing on a basic example.<BR><BR>

<U>Related functions:</U><BR>

<CENTER>		WriteEv, LoadEv<BR>
		ChoixScene, PlusScene<BR>
		Init16<BR>
		EvPlot<BR>
		ActiveCanal, DesactiveCanal,<BR> 
		ActiveTout, DesactiveTout, <BR>
		ActiveRegion, DesactiveRegion<BR>
</CENTER>
<BR><BR>

<HR><BR>
<A NAME="lignes">Another important data structure is the <B>ligne</B>. It's a French word meaning "line". This is the type of array returned by a <A HREF="GMprojectors.html">projector</A>. It contains the musical phrase, but also some information on the way it has been calculated, so that you can have a look at the intermediary states of the calculation and maybe use them into your composition.<BR><BR> Here is the format:<BR><BR></A>
<B> ligne["ph"]</B>	this is the rendered phrase, what you will eventually want to hear !<BR>
<B> ligne[0]	 </B> ...its starting time<BR>
<B> ligne[1]	 </B> ...its ending time<BR>
<B> ligne["para"]  </B> may keep a record of some of the arguments in the projector call<BR>
<B> ligne["rac"]</B> is an array whose format is projector-specific. It is used to help make a transition from this projector to an associated or following other projector, in a particular algorithm.Usually, it records the last position of a moving segment or circle  (see the projector <A HREF="GMprojectors.html#Bro">brown</A> for an example)<BR>
<B> ligne["inter"] </B> is also an array with a format depending on the projector. It is used to store intermediary positions or states in the calculation. See the <A HREF="GMprojectors.html#C4">projectors documentation</A> for details.<BR><BR>

<BR><BR>

<HR><BR>
<A NAME="collec">A <B>collection</B> is a set of events all belonging to the same channel.<BR><BR></A>

<B>coll["nom"]</B>	collection name<BR>
<B>coll["ch"]	 </B> collection channel<BR>
<B>coll[0]</B>	number of events<BR>
<B> coll[n]</B> event number n<BR>

<BR>
<U>Related functions:<BR></U>
	<CENTER>	Convo, Rot, Sca, ScaXY, Trans<BR>
		CExport, CImport, ListColl<BR>
		PlusCol<BR>
		Maillage<BR>
		Idem, DansChoix, RandomNotes<BR></CENTER>
<BR><BR>
<HR><BR>
<A NAME="pistes">A <B>piste</B> is simply a list of points<BR><BR></A>

<B>piste[0]</B> number of points<BR>
<B>piste[n]</B> point number n<BR>
<BR>
<U>Related functions:<BR></U>
	<CENTER>	Piste	<BR>		Rot, Trans, Sca, ScaXY<BR>		List, ListPiste<BR></CENTER>
<BR><BR>

<HR><BR>
<A NAME="regions">A <B>region </B>is an array defining a part of the event scene by giving a set of conditions on the channel and on the position of events.<BR><BR></A>

<B>blob[0]</B>	number of tests <BR>
<B>blob[n]</B>	test number n<BR>
<BR>
blob[1] to blob[n] are strings: they are supposed to contains test conditions on the variables X_, Y_ and C_ (for example "X_*X_+Y_*Y_ <= 2" or "(C_ > 10) && (C_ < 16)" ).<BR><BR>
 The final region is defined by blob[0] || blob[1] || ... || blob[n].
<BR><BR>
<U>Related functions:<BR></U>
<CENTER>		RegionET, RegionOU, RDisque, RTri, RRect, RCanal<BR>
		Geo<BR>
		ActiveRegion, DesactiveRegion<BR></CENTER>
<BR><BR><BR><BR>

<HR><HR><BR><H2>Structures of general interest</H2><BR>
<HR><BR>
<A NAME="points"><B>points/vectors</B></A>
<BR><BR>
<B> v = ["x", "y"]</B>	    <BR>
or<BR>
<B> v = ["r", "theta"]</B>	only for use with Getpolar() and Setpolar()<BR><BR>
You can use the xy() KeyKit function to define a point, but beware that this function transform float arguments to integers. So it's better to use the xyd() function ("d" stands for "decimal"), and you need to if you want to give float values to "x" or "y").<BR><BR>
<U>Related functions:<BR></U>
<CENTER>xyd</CENTER>
	<CENTER>	Geo, Setpolar, Getpolar, Dist<BR>		ListSeg<BR></CENTER><BR><BR>

<HR><BR>
<A NAME="segments"><B>segments</B></A>
<BR><BR>
<B>seg = ["x0", "y0", "x1", "y1"]</B><BR><BR>
... same thing here about xy() and xyd().<BR>
<BR>
<U>Related functions:<BR></U>
<CENTER>Seg</CENTER>
<BR><BR>
<HR><BR>
<A NAME="circles"><B>circles</B></A>

<BR><BR><B>cir = ["c", "r"]</B> were "c" is a point and "r" a float<BR><BR>
<U>Related functions:<BR></U>
<CENTER>cr</CENTER>
<CENTER>Geo, ListCer, Peri</CENTER><BR><BR><BR>

<HR><BR>
<A NAME="log"><B>LOG</B></A>
<BR><BR>
<B>LOG[n]</B> string recording a console command line (from Hist)<BR><BR>
LOG is a reserved global variable intended to save part of the console History, in order to use it in a function definition or as a script-like feature. You can define with <B>HLog() </B>which parts of the History you want to keep in LOG. You can evaluate LOG like a program with <B>EvaLog()</B>. You can write LOG as a function in a .k file with <B>ExLog()</B>.<BR><BR>
<BR>
<U>Related functions:<BR></U>
<CENTER>HLog, EvaLog, ExLog</CENTER><BR>
<BR><BR>
<HR><BR>
<A NAME="mem"><B>memories</B>: <B>FT</B>, <B>FKK</B>, <B>FIF</B> and <B>SNARF</B></A>
<BR><BR>
These are history arrays associated with different things: <BR><BR>
<B>FT</B> stores formula strings used when calling  Distort01()<BR>
<B>FKK</B> stores formula strings used when calling KKSR() or KKSS() (which happens when you use the <A HREF="GMtool.html#operation">"operation" button </A>in the graphic tool)<BR>
<B>FIF</B> stores test statements like the ones used by the <A HREF="GMtool.html#actif">activation buttons</A> of the GUI.<BR><BR>
A basic history feature is implemented in the GUI using these arrays. For exemple, typing "<B>::</B>" at the prompt for "operation" recalls the last formula you typed there.<BR><BR>
<B>SNARF</B> is an extended Snarf, storing phrases used as argument to Snarph(). The Snarf itself is not automatically stored in SNARF. You have to make a "Snarph(Snarf)" for that. The Snarph() function is also used to get the phrases back and to delete some of them.<BR><BR>
All these arrays are dumped with the GUI tool, so you can keep them from an invocation of KeyKit to another by writing pages (.kp files). See KeyKit documentation for more about that.<BR><BR>
<U>Related functions:<BR></U>
<CENTER>Snarph</CENTER><BR>
<BR><BR><BR><BR><BR>
<CENTER>-- <A HREF="eGM0.html">Back </A>--</CENTER>
</BODY>
</HTML>